\subsection{Inlining}

The last important difference is inlining.
While Stan follows a similar design of representing
expression nodes with classes and having each class implement
specific logic for forward and backward-evaluation,
Stan uses dynamic polymorphism whereas FastAD uses static polymorphism.
Dynamic polymorphism inevitably invokes virtual function calls,
which cannot be inlined except in extremely rare cases
with the highest compiler optimization.
Virtual function calls can be expensive, especially if called often and
if the function itself is relatively cheap.
We saw in Sections~\ref{ssec:unary}-\ref{ssec:normal_log_pdf}
that forward and backward-evaluations are quite simple for each node
which only take up a few lines of code.
Such functions are best inlined to increase instruction cache hits
and remove the cost of function calls.
Expression templates by design make it very easy for the compiler to inline
because there are no virtual functions to begin with
and all functions can be specified to be inlined (although this is still only a suggestion).
