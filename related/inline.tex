\subsection{Inlining}

The last important difference is inlining.
While Stan follows a similar design of representing
expression nodes with classes and having each class implement
specific logic for forward and backward-evaluation,
Stan uses dynamic polymorphism.
This inevitably invokes virtual function calls,
which cannot be inlined except in extremely rare cases
with the highest compiler optimization.
Function calls are generally very expensive, especially if called often,
as is the case in AD.
If each function call takes a relatively long time to finish,
even this frequent virtual function call may be negligible,
but in most use-cases, that is not the case.

We saw in Sections~\ref{ssec:unary}-\ref{ssec:normal_log_pdf}
that forward and backward-evaluations are quite simple for each node
which only take up a few lines of code.
It is best if these functions are inlined to increase instruction cache hits
and remove the cost of function calls.
Expression templates by design make it very easy for the compiler to inline
the logic for AD evaluations because there are no virtual functions
and all functions are specified to be inlined (although this is still only a suggestion).
