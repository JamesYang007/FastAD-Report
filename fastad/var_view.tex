\subsection{Class VarView}\label{ssec:var_view}

A \code{VarView} object is an AD expression node
that views the values and adjoints of an independent variable.
In Fig.~\ref{fig:expr-tree-example}, the \code{VarView} objects are precisely the $w_i$ nodes.
The following is a simplified definition of its base class, 
which implements all of the important members:
\begin{lstlisting}[style=customcpp]
template <class ValueType
        , class ShapeType>
struct VarViewBase<VarView<ValueType, ShapeType>>:
    core::ValueAdjView<ValueType, ShapeType>,
    core::ExprBase<VarView<ValueType, ShapeType>>
{
    // ...
    VarViewBase(value_t* val,
                value_t* adj,
                size_t rows,
                size_t cols)
        : value_adj_view_t(val, adj, rows, cols)
    {}

    const var_t& feval() const { return this->get(); }

    template <class T>
    void beval(const T& seed) { 
        util::to_array(this->get_adj()) += seed; 
    }

    template <class T>
    constexpr T bind_cache(T begin) { return begin; }
    util::SizePack bind_cache_size() const { return {0,0}; }
    util::SizePack single_bind_cache_size() const { return {0,0}; }
};
\end{lstlisting}

\code{VarView} inherits \code{ValueAdjView} and hence views
a region for values and adjoints.
The second base class \code{ExprBase} utilizes Curiously Recurring Template Pattern (CRTP)~\cite{abrahams:2005},
which is a common technique to tag classes to unify a collection of classes as one concept.
Every expression node must implement the five member functions shown above.
The member \code{feval} represents the forward-evaluation.
For a \code{VarView} object, it just return its value.
The member \code{beval} represents the backward-evaluation.
As described in Section~\ref{sec:reverse}, 
these nodes must increment the adjoints of the actual variables they reference.
The helper function \code{to\_array} takes the argument and returns the ``array'' version.
For scalars, it returns the argument itself.
However, for \code{Eigen} matrix-like objects, 
it returns the result of calling \code{x.array()}, where \code{x} is the argument.
The reason for this is that sometimes the seed may be a scalar
when the adjoint may be a vector or a matrix.
Unfortunately, \code{Eigen} matrix-like objects do not play well with element-wise operations,
and such API is only available for array-like objects.
Note that the conversion from a matrix object to an array object 
is cost-free (done at compile-time) and it only serves to expose a different API.\@

The purpose for the \code{cache}-related functions was detailed in Section~\ref{ssec:example}.
For a \code{VarView} object, 
since it has no children and it does not need to bind to any cache,
\code{bind\_cache\_size} returns $ 0$ for both value and adjoint sizes,
and \code{bind\_cache} returns the argument back.
\code{single\_bind\_cache\_size} returns the number of values and adjoints required
for the current expression node only (non-recursive) 
(see Section~\ref{ssec:eq} for how this is used).
This, too, returns $ 0$ for both sizes.

\code{VarView} objects are extremely useful because it gives the user full control 
of the memory layout of the values and adjoints for the independent variables.
Often times, a function consists of many different variables of various shapes,
but the user wishes to collapse all of these variables into one long vector.
This usually occurs when each value needs to get updated by its adjoint,
hence it is faster to take the vector of all values and update it with the entire adjoint vector at once.
However, it is not intuitive to directly work with this collapsed vector,
since the expression to construct is best defined with the separate independent variables.
\code{VarView} remedies this situation by adding a layer of abstraction.
A user can prepare this collapsed vector and create different \code{VarView}
objects to view the correct parts of this vector.
These \code{VarView} objects can then create the expression.
An example code may look like the following:
\begin{lstlisting}[style=customcpp]
    Eigen::VectorXd val(10);
    Eigen::VectorXd adj(10);

    // scalar w
    VarView<double, scl> w(val_buf.data(), 
                           adj_buf.data());

    // 3x3 matrix Sigma
    VarView<double, mat> Sigma(val_buf.data() + 1,
                               adj_buf.data() + 1,
                               3, 3);

    // define expression using w, Sigma
    // differentiate
    // update value with adjoint
    val += 2 * adj;
\end{lstlisting}

After modifying the value vector, if the user wishes to differentiate with these new values,
they can reuse the \code{VarView} and the expression objects.
The only catch is that the adjoint vector must be reset to 0 before differentiating again,
since \code{VarView} is defined to always increment the adjoints.
