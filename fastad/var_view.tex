\subsection{Class VarView}\label{ssec:var_view}

A \verb|VarView| object is an AD expression node
that views the values and adjoints of an independent variable.
In Fig.~\ref{fig:expr-tree-example}, the \verb|VarView| objects are precisely the $w_i$ nodes.
The following is a simplified definition of its base class, 
which implements all of the important members:
\begin{lstlisting}[style=customcpp]
template <class ValueType
        , class ShapeType>
struct VarViewBase<VarView<ValueType, ShapeType>>:
    core::ValueAdjView<ValueType, ShapeType>,
    core::ExprBase<VarView<ValueType, ShapeType>>
{
    // ...
    VarViewBase(value_t* val,
                value_t* adj,
                size_t rows,
                size_t cols)
        : value_adj_view_t(val, adj, rows, cols)
    {}

    const var_t& feval() const { return this->get(); }

    template <class T>
    void beval(const T& seed) { 
        util::to_array(this->get_adj()) += seed; 
    }

    template <class T>
    constexpr T bind_cache(T begin) { return begin; }
    util::SizePack bind_cache_size() const { return {0,0}; }
    util::SizePack single_bind_cache_size() const { return {0,0}; }
};
\end{lstlisting}

\verb|VarView| inherits \verb|ValueAdjView| and hence views
a region for values and adjoints.
The second base class \verb|ExprBase| utilizes Curiously Recurring Template Pattern (CRTP).
This is a common technique to tag certain classes to unify various classes as one ``concept''
\todo{find some reference for this?}.
Every expression node must implement the five member functions shown above.
The member \verb|feval| represents the forward-evaluation.
In the case for \verb|VarView| objects, 
they simply need to retrieve and return the value that they represent.
The member \verb|beval| represents the backward-evaluation.
As described in Section~\ref{sec:reverse}, 
these nodes must increment the adjoints of the actual variables they reference.
The helper function \verb|to_array| takes the argument and returns the ``array'' version.
For scalars, it returns the argument itself.
However, for \verb|Eigen| matrix-like objects, 
it returns the result of calling \verb|x.array()|, where \verb|x| is the argument.
The reason for this is that sometimes the seed may be a scalar
when the adjoint may be a vector or a matrix.
Unfortunately, \verb|Eigen| matrix-like objects do not play well with element-wise operations,
and such API is only available for array-like objects.
Note that the conversion from a matrix object to an array object 
is cost-free (done at compile-time) and it only serves to expose a different API.\@

The next three members define how lazy allocation is performed.
We refer to the memory region allocated for values and adjoints for
expression nodes as the \emph{cache}.
Note that this does not include the value and adjoint region 
for the independent variables and its viewers,
e.g. $x_i$ and $w_i$ in Fig.~\ref{fig:expr-tree-example}.
\verb|bind_cache_size| is a member that computes the number of value and adjoint elements
needed for the subtree starting at the current expression node.
\verb|single_bind_cache_size| is a member that computes the number of value and adjoint elements
for the current expression node only (non-recursive).
For a \verb|VarView| object,
since it has no children and it does not need to bind to any cache,
it returns $ 0$ for both sizes as a \verb|SizePack|,
which is a class that contains two unsigned long integers
that represent the value and adjoint sizes.
\verb|bind_cache| takes its argument,
which will usually be a pointer pack object mentioned in Section~\ref{ssec:value_adj_view},
and if cache is required for the current node,
bind itself to view the value and adjoint region using the pointer pack
and return the pack pointing to the next unbound location.
In the case of \verb|VarView|, however, it just returns the argument back
because it does not need to bind to any cache.

\verb|VarView| objects are extremely useful because it gives the user full control 
of the memory layout of the values and adjoints for the independent variables.
Often times, a function consists of many different variables of various shapes,
but the user wishes to collapse all of these variables into one long vector.
This usually occurs when each value needs to get updated by its adjoint,
hence it is faster to take the vector of all values and update it with the entire adjoint vector at once.
However, it is not intuitive to directly work with this collapsed vector,
since the expression to construct is best defined with the separate independent variables.
\verb|VarView| remedies this situation by adding a layer of abstraction.
A user can prepare this collapsed vector and create different \verb|VarView|
objects to view the correct parts of this vector.
These \verb|VarView| objects can then create the expression.
An example code may look like the following:
\begin{lstlisting}[style=customcpp]
    Eigen::VectorXd val(10);
    Eigen::VectorXd adj(10);

    // scalar w
    VarView<double, scl> w(val_buf.data(), 
                           adj_buf.data());

    // 3x3 matrix Sigma
    VarView<double, mat> Sigma(val_buf.data() + 1,
                               adj_buf.data() + 1,
                               3, 3);

    // define expression using w, Sigma
    // differentiate
    // update value with adjoint
    val += 2 * adj;
\end{lstlisting}

After modifying the value vector, if the user wishes to differentiate with these new values,
they can reuse the \verb|VarView| and the expression objects.
The only catch is that the adjoint vector must be reset to 0 before differentiating again,
since \verb|VarView| is defined to always increment the adjoints.
