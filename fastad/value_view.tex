\subsection{Class ValueView}\label{ssec:value_view}

The first class template we discuss is \code{ValueView}.
As mentioned in Section~\ref{sssec:lazy-alloc},
every expression node simply needs to view a region of memory as its value and adjoint.
More generally, this leads to creating a class that views some memory region
and exposes a useful API for the expression nodes.
The following is the forward-declaration of \code{ValueView}:
\begin{lstlisting}[style=customcpp]
    template <class ValueType, class ShapeType>
    struct ValueView;
\end{lstlisting}
\code{ValueType} indicates the underlying value type, which is usually \code{double}.
\code{ShapeType} is a tag that indicates the general shape of the value.
It must be one of \code{ad::scl}, \code{ad::vec}, or \code{ad::mat} 
indicating scalar, vector, or matrix shape, respectively.
This extra shape information has proven to be very helpful in making compile-time optimizations
(see Section~\ref{ssec:normal_log_pdf}).

The following is a simplified version of \code{ValueView} specialized for scalars and vectors.
We omit the specialization for matrices since it is very similar to that of vectors:
\begin{lstlisting}[style=customcpp]
template <class ValueType>
struct ValueView<ValueType, scl>
{
    ValueView(value_t* begin, size_t=1, size_t=1)
        : val_(begin) {}

    var_t& get() { return *val_; }
    const var_t& get() const { return *val_; }

    value_t* bind(value_t* begin)
    { val_ = begin; return val_ + this->size(); }

private:
    value_t* val_;
};

template <class ValueType>
struct ValueView<ValueType, vec>
{
    ValueView(value_t* begin, size_t rows, size_t=1)
        : val_(begin, rows)
    {}
     
    var_t& get() { return val_; }
    const var_t& get() const { return val_; }

    value_t* bind(value_t* begin)
    { 
        new (&val_) var_t(begin, this->size());
        return begin + this->size(); 
    }

private:
    var_t val_;
};
\end{lstlisting}
Note that the constructor always takes in two size parameters.
This is to keep the API consistent for all specializations.
\code{begin} points to the beginning of the memory that we wish to view
and is used to bind the underlying pointer.
\code{get} will always return a reference to the ``whole value''.
In the case of scalar, the whole value is simply the first value.
However, in the case of vector or matrix shape, the whole value is the vector or the matrix.
\code{bind} allows the object to lazily rebind to a memory region
starting at \code{begin} and always returns the pointer to the next unbound location.
This will play a critical role in employing lazy allocation (see Section~\ref{sssec:lazy-alloc}).
In the scalar case, since it only views one value, 
it will first save the pointer \code{begin} and return \code{begin + 1}.
In the vector and matrix case, it will save the pointer 
using the overloaded \code{new} operator for \code{Eigen::Map} objects and return \code{begin + size},
where \code{size} is the total number of elements.
\code{Eigen::Map} is an object that can view a region of memory as a vector or a matrix.
The benefit is that \code{Eigen} API can then be reused such as 
matrix multiplication, vectorized unary operation, etc.
Note that \code{new} does not heap-allocate for \code{Eigen::Map} objects, 
rather it just sets some pointers and integers.
