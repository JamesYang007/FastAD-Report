\subsection{Binary Node}\label{ssec:binary}

\code{BinaryNode} represents any element-wise binary operation.
It is a well-defined operation between a scalar and any shape 
and between two objects with the same shape.
\code{BinaryNode} is very similarly written as \code{UnaryNode} shown in Section~\ref{ssec:unary}.
For this reason, we do not show the full code,
but only the backward-evaluation to illustrate why we need to save the seeds.
The following is the simplified logic for backward-evaluation:
\begin{lstlisting}[style=customcpp]
    template <class T>
    void beval(const T& seed)
    {
        auto&& a_val = util::to_array(this->get());
        auto&& a_adj = util::to_array(this->get_adj());
        auto&& a_l = util::to_array(expr_lhs_.get());
        auto&& a_r = util::to_array(expr_rhs_.get());

        a_adj = seed;
        auto&& rhs_seed = Binary::brmap(a_adj, a_l, a_r, a_val);
        auto&& lhs_seed = Binary::blmap(a_adj, a_l, a_r, a_val);
        expr_rhs_.beval(rhs_seed);
        expr_lhs_.beval(lhs_seed);
    }
\end{lstlisting}
The first four lines prepare array-like versions of the 
forward-evaluated value, current node's adjoint, and
left and right expression's forward-evaluated values.
The next line evaluates and saves the seed expression into the node's adjoint.
The class \code{Binary} has members \code{blmap} and \code{brmap}
referring to the backward-evaluation method for the left and right expressions, respectively.
Like the \code{Unary} class for \code{UnaryNode},
this returns an \code{Eigen} expression for vectors and matrices.
If the seed were not evaluated and saved into \code{a\_adj}
and \code{seed} were passed in as the first parameter instead to \code{blmap} and \code{brmap},
\code{rhs\_seed} and \code{lhs\_seed} would contain a copy of the \code{seed} expression.
When backward-evaluating on the children,
the \code{seed} expression will eventually be evaluated at least twice.
In fact, if the left and right expressions also contain \code{BinaryNode}s,
then they will each copy this \code{seed} expression to their children,
requiring exponentially more evaluations.
This is a form of dynamic programming where saving the \code{seed} can save tremendous amount of time.
This method was mentioned in other literature and it remains relevant in our design as well~\cite{carpenter:2015}.
