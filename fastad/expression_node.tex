\subsection{Expression Node}

As mentioned in Section~\ref{ssec:var_view},
all other expression nodes only need to
implement the five member functions: \verb|feval|, \verb|beval|,
\verb|bind_cache|, \verb|bind_cache_size|, and \verb|single_bind_cache_size|.
We describe how some of the most common expression nodes are defined
to demonstrate that this design, in fact, holds generally and 
can be easily implemented for any kind of expression nodes.

\subsubsection{Unary}

A unary operation on a scalar, vector, or a matrix is a vectorized 
operation applying a function $\phi$ element-wise.
More concretely, we say $f$ is a (vectorized) unary function if
\[
    f(x) = {[\phi(x_{ij})]}_{i=1,j=1}^{m,n}
\]
The following is a simplified definition of a unary expression node:
\begin{lstlisting}[style=customcpp]
template <class Unary
        , class ExprType>
struct UnaryNode:
    ValueAdjView<typename util::expr_traits<ExprType>::value_t,
                 typename util::shape_traits<ExprType>::shape_t>,
    ExprBase<UnaryNode<Unary, ExprType>>
{
    UnaryNode(const expr_t& expr)
        : value_adj_view_t(nullptr, nullptr, expr.rows(), expr.cols())
        , expr_(expr)
    {}

    const var_t& feval() {
        auto&& a_expr = util::to_array(expr_.feval());
        util::to_array(this->get()) = Unary::fmap(a_expr);
        return this->get();
    }

    template <class T>
    void beval(const T& seed) {
        auto&& a_val = util::to_array(this->get());
        auto&& a_adj = util::to_array(this->get_adj());
        auto&& a_expr = util::to_array(expr_.get());
        a_adj = seed;
        expr_.beval(Unary::bmap(a_adj, a_expr, a_val));
    }

    ptr_pack_t bind_cache(ptr_pack_t begin) { 
        begin = expr_.bind_cache(begin);
        return value_adj_view_t::bind(begin);
    }

    util::SizePack bind_cache_size() const { 
        return single_bind_cache_size() + 
                expr_.bind_cache_size();
    }

    util::SizePack single_bind_cache_size() const {
        return {this->size(), this->size()};
    }

private:
    expr_t expr_;
};
\end{lstlisting}

A unary expression node is also a viewer of value and adjoint.
It is also an expression node, and hence is tagged with \verb|ExprBase|.
The constructor initializes the viewer with null pointers and the correct size.
Because a unary operation is always vectorized,
the value and adjoint size is always the same as the operand's size.
The first template parameter \verb|Unary| is a type that defines
static member functions \verb|fmap| and \verb|bmap|,
which define how to forward and backward-evaluate the current node, respectively.

The forward-evaluation defined by \verb|feval| first
forward-evaluates the operand \verb|expr_| and then applies the unary operation
on the result by delegating to \verb|Unary::fmap|.
We then save and return this result.

The backward-evaluation defined by \verb|beval| first saves the seed to its adjoint.
It is important to save the seed because in general it may be some 
non-trival \verb|Eigen| expression.
In general, if we do not evaluate and save the seed,
we may recompute the same expression for the seed multiple times 
when we backward-evaluate its children.
We compute the seed for the operand by delegating to \verb|Unary::bmap|.
Note that we pass in the current adjoint \verb|a_adj|, 
operand value \verb|a_expr|, and 
the forward-evaluated result \verb|a_val|.
We pass the seed because the next seed to compute may be more efficiently written 
than writing \verb|seed * Unary::bmap(a_expr, a_val)|.
For example, if \verb|Unary| represents \verb|log|,
the current approach can return \verb|seed / a_expr|, however
the less efficient approach will return \verb|seed * (1./a_expr)|,
which requires an extra multiplication.
In fact, if the underlying expression is a vector or a matrix,
the extra multiplication is per element, so there is a lot of extra computation.
This optimization refers back to Section~\ref{sssec:lazy-eval} regarding lazy evaluation.
We pass the forward-evaluated result because
some unary operations may be more optimized to reuse this value,
for example, exponential function.

The cache-related logic in the general case was already explained in Section~\ref{ssec:var_view}.

The following is an example of a Unary struct that will get passed in 
as the first template parameter to \verb|UnaryNode|.
We show the definition for exponential:
\begin{lstlisting}[style=customcpp]
struct Exp
{
    template <class T>
	inline static auto fmap(const T& x) {
        using std::exp;
        using ad::exp;
        using Eigen::exp;
        return exp(x);
	}
    template <class S, class T, class U> 
	inline static auto bmap(const S& seed,
                            const T& x,
                            const U& f) {
        return seed * f;
	}
};
\end{lstlisting}

The final piece is defining a function that will create such a node.
It is important to create such a function rather than explicitly
construct this \verb|UnaryNode| object because function templates
are able to deduce the types of its arguments, which is crucial when using expression templates,
since the types of expressions can be arbitrarily complex.
The following is the \verb|exp| definition:
\begin{lstlisting}[style=customcpp]
template <class Derived
        , class = std::enable_if_t<
            util::is_convertible_to_ad_v<Derived>>> 
inline auto exp(const Derived& node) 
{ 
    using expr_t = util::convert_to_ad_t<Derived>;
    expr_t expr = node;
    if constexpr (util::is_constant_v<expr_t>) { 
        return ad::constant(core::Exp::fmap(
                    util::to_array(expr.feval())) ); 
    } else { 
        return core::UnaryNode<core::Exp, expr_t>(expr); 
    } 
}
\end{lstlisting}
The second template parameter is a way to perform 
Substitution-Failure-Is-Not-An-Error (SFINAE) pattern \todo{cite?}.
This function is only enabled when the operand expression \verb|node|
``can be converted to an AD expression''.
Broadly, we defined this metaprogramming tool to check if 
\verb|node| is a literal, an \verb|Eigen| object, 
or already an AD expression (tagged with \verb|ExprBase|),
since a literal or an \verb|Eigen| object can be wrapped as a \verb|ConstantNode|,
which is an AD expression, or if it already is an AD expression, no conversion is needed.
The \verb|convert_to_ad_t| will then convert the original type to the corresponding AD expression type,
and this converted object \verb|expr| gets used 
to construct the \verb|UnaryNode| with \verb|Exp| as the first template parameter.
We make a further optimization to check at compile-time whether \verb|expr|
is a constant AD expression, if so, this is eagerly evaluated.
This helps a lot during the actual AD evaluation since if we were to lazily evaluate constants,
we would evaluate them multiple times unnecessarily.
