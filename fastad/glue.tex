\subsection{Glue Node}\label{ssec:glue}

As mentioned in Section~\ref{ssec:eq},
the comma operator is also overloaded to return an expression.
This operator is what chains multiple expressions together to form a program.
The following is a simplified definition of the member functions only:
\begin{lstlisting}[style=customcpp]
    const var_t& feval()
    {
        expr_lhs_.feval(); 
        return this->get() = expr_rhs_.feval();
    }

    template <class T>
    void beval(const T& seed)
    {
        expr_rhs_.beval(seed); 
        expr_lhs_.beval(0);
    }

    ptr_pack_t bind_cache(ptr_pack_t begin)
    {
        begin = expr_lhs_.bind_cache(begin);
        begin = expr_rhs_.bind_cache(begin);
        value_adj_view_t::bind({expr_rhs_.data(), 
                                expr_rhs_.data_adj()});
        return begin;
    }

    util::SizePack bind_cache_size() const 
    { 
        return expr_lhs_.bind_cache_size() + 
                expr_rhs_.bind_cache_size();
    }

    util::SizePack single_bind_cache_size() const
    { return {0,0}; }
\end{lstlisting}
The definition is extremely simple.
A \verb|GlueNode| is defined to always view the right-expression's values and adjoints,
since in C++ the usual comma operator would only keep the right-expression value.
\verb|feval| just forward-evaluates left-to-right and \verb|beval| backward-evaluates right-to-left.
One caveat is that only the right-expression is given the seed and the left-expression is seeded with 0.
This is, again, because the node represents the right expression and hence differentiates only that expression.
It is still consistent with all other nodes, including \verb|EqNode|.
In the example in Section~\ref{ssec:eq}, the assignment expression is indeed seeded with 0.
This does not mean that \verb|t| has an adjoint of 0.
The backward-evaluation of the second expression will have first accumulated the adjoints for \verb|t|
and when backward-evaluating the assignment expression, 0 gets accumulated to the adjoint.
