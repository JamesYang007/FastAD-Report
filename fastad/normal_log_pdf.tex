\subsection{Normal Log-PDF Node}\label{ssec:normal_log_pdf}

One of the most common functions used in statistical inference methods
is the log-pdf of the normal distribution.
Hence, it is worth optimizing this expression node as much as possible.
The current design of FastAD is already quite optimized for all nodes,
but we show that we can make further compile-time optimizations to minimize computations.

It is useful to have versions of log-pdf that drop any unnecessary constants,
hence, we defined our normal log-pdfs to drop the $\sqrt{2\pi}$ constant.
The following is the forward-declaration of the normal log-pdf node:
\begin{lstlisting}[style=customcpp]
template <class XExprType
        , class MeanExprType
        , class SigmaExprType
        , class = std::tuple<
            typename util::shape_traits<XExprType>::shape_t,
            typename util::shape_traits<MeanExprType>::shape_t,
            typename util::shape_traits<SigmaExprType>::shape_t> >
struct NormalAdjLogPDFNode;
\end{lstlisting}
The first three template parameters are the expression types for
$x$, $\mu$, and $\sigma$, where $\sigma$ is either the standard deviation
(or a vector of standard deviations) or the covariance matrix if matrix shape.
At compile-time, we make assertions to make sure the relative sizes of
$x, \mu, \sigma$ make sense.
For example, we can catch at compile-time 
if $x$ and $\sigma$ are scalars, but $\mu$ is a vector, and 
raise an error since this is an undefined combination.
The fourth template parameter is used to perform SFINAE.\@
Depending on the combination of the shapes of $x,\mu,\sigma$,
we can choose the specialization of this node at compile-time and 
generate code specific to that particular combination.
At run-time, there are no conditional statements to choose the correct code.
It is worth writing different specializations because in most of the cases
there are different opportunities to save computations.

The following is a simplified version of the specialization 
for when $x$ is a vector and $\mu, \sigma$ are scalars, 
showing only the constructor and the forward-evaluation:
\begin{lstlisting}[style=customcpp]
    NormalAdjLogPDFNode(const x_t& x,
                        const mean_t& mean,
                        const sigma_t& sigma)
        : base_t(x, mean, sigma)
        , log_sigma_{0}
        , z_sq{0}
        , x_mean_{0}
        , x_var_{0}
    {
        if constexpr (util::is_constant_v<sigma_t>) {
            this->update_cache();
        }

        if constexpr (util::is_constant_v<x_t>) {
            x_mean_ = x_.get().mean();
            x_var_ = (x_.get().array() - x_mean_).matrix().squaredNorm();
        }
    }

    const var_t& feval()
    {
        auto&& x = x_.feval().array();
        auto&& m = mean_.feval();
        auto&& s = sigma_.feval();

        if (s <= 0) return this->get() = util::neg_inf<value_t>;

        if constexpr (!util::is_constant_v<sigma_t>) {
            this->update_cache();
        }

        if constexpr (util::is_constant_v<x_t>) {
            value_t centered = (m - x_mean_);
            value_t inv_s_sq = 1./(s * s);
            return this->get() = 
                -0.5 * inv_s_sq * (x_var_ + x_.rows() * centered * centered) 
                        - x_.rows() * log_sigma_;
        } else { auto z = (x - m).matrix();
            z_sq = z.squaredNorm() / (s * s);
            return this->get() = -0.5 * z_sq - x_.rows() * log_sigma_; 
        }
    }
\end{lstlisting}
We provide a metaprogramming tool to check if an AD expression is a constant.
In the constructor, we check at compile-time if $\sigma$ is a constant.
If so, we eagerly update some information related to $\sigma$.
For this node, we simply compute $\log(\sigma)$ and store it in \code{log\_sigma\_}.
During AD evaluations, we can reuse this value, saving repeated calls to the expensive \code{log} function.
If $x$ is constant, we can actually compute the log-pdf in a different way:
\begin{align}
    \log(p(x|\mu, \sigma)) 
    &= -\frac{1}{2 \sigma^2} 
        \sum\limits_{i=1}^n (x_i - \mu)^2 
        - n\log(\sigma) \label{eq:normal_log_pdf} \\
    &= -\frac{1}{2 \sigma^2} 
        \paren{\sum\limits_{i=1}^n (x_i - \bar{x})^2 + n(\bar{x} - \mu)^2} 
        - n\log(\sigma) \label{eq:normal_log_pdf_x_const}
\end{align}
This is helpful because we can one-time evaluate $\sum\limits_{i=1}^n (x_i - \bar{x})^2$ and $\bar{x}$.
These values can then be reused for multiple evaluations and now the complexity of log-pdf
reduced from an $O(n)$ operation to $O(1)$.
The forward-evaluation reflects this logic.
If $\sigma$ is not a constant, it must re-evaluate $\log(\sigma)$ 
since the value may have changed across multiple evaluations.
If $x$ is a constant, we compute as shown in Eq.~\ref{eq:normal_log_pdf_x_const},
otherwise, we compute as shown in Eq.~\ref{eq:normal_log_pdf}.
We emphasize that all of these checks are done at compile-time 
and no conditional statements are invoked during run-time.
