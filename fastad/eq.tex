\subsection{Eq Node}\label{ssec:eq}

So far, we have only considered expressions that could be fully specified in one step.
However, in practice, expressions may need to be broken up into multiple steps
to avoid unnecessary computations.
For example, consider the function
\begin{align}
    f(x,w) = xw + \sin(xw) \label{eq:eq-example}
\end{align}
If we naively implement this function in FastAD, 
we would generate the following expression:
\begin{lstlisting}[style=customcpp]
    auto expr = (x * w + ad::sin(x * w));
\end{lstlisting}
This would, unfortunately, compute \code{x * w} twice.
If \code{x} and \code{w} were large matrices and instead of \code{x * w}
we had \code{ad::dot(x, w)} representing matrix multiplication,
this extra computation would be quite significant.
FastAD provides a way to assign an expression to a variable as a placeholder.
This is the job of \code{EqNode}.
The following is a simplified definition of the member functions of \code{EqNode}:
\begin{lstlisting}[style=customcpp]
    const var_t& feval()
    {
        return this->get() = var_view_.get() = expr_.feval();
    }

    template <class T>
    void beval(const T& seed)
    {
        var_view_.beval(seed);
        auto&& a_adj = util::to_array(var_view_.get_adj());
        expr_.beval(a_adj);
    }

    ptr_pack_t bind_cache(ptr_pack_t begin)
    {
        ptr_pack_t var_ptr_pack(var_view_.data(), 
                                var_view_.data_adj());
        value_adj_view_t::bind(var_ptr_pack);
        begin = expr_.bind_cache(begin);
        auto size_pack = expr_.single_bind_cache_size();
        begin.val -= size_pack(0);
        begin.adj -= size_pack(1);

        expr_.bind(var_ptr_pack);

        return begin;
    }

    util::SizePack bind_cache_size() const 
    { 
        return expr_.bind_cache_size() - 
                expr_.single_bind_cache_size();
    }

    util::SizePack single_bind_cache_size() const 
    { return {0,0}; }
};
\end{lstlisting}
It is worth explaining each member function again, 
since their behaviors are all unique to this node.
Here, \code{var\_view\_} is a \code{VarView} object that represents the placeholder
and \code{expr\_} represents the expression to assign.

The only cache function we discuss is \code{bind\_cache}.
The others will follow immediately.
Because \code{EqNode} can be thought of as a simple wrapper of the \code{var\_view\_},
it has no reason to request cache to store its value and adjoint --- 
they will always be the same as those of \code{var\_view\_}.
Hence, the node can simply view the same value and adjoint that \code{var\_view\_} views.
Moreover, \code{expr\_} will always have the same value as \code{var\_view\_} by definition.
Once \code{expr\_} is bound to cache, 
we can ``strip'' just the root of \code{expr\_}
of its value and adjoint cache and force it to view those of the variable.
This way we reduce unnecessary copies and at the time of forward-evaluation,
\code{expr\_} will write directly to \code{var\_view\_}.
For this reason, we must subtract the 
single cache size of the root of \code{expr\_} from 
its total cache size.

\code{feval} first forward-evaluates the right-side expression
and stores the result into the variable on the left-side
as well as to the value region of the \code{EqNode}.
In most cases, some of the assignments will essentially be a no-op
if there is reflexivity, however in general, we need all of these assignments
because the parent of the current node could also be an \code{EqNode}
which will then strip the current \code{EqNode} of its value and adjoint
to view elsewhere.

\code{beval} accumulates the adjoint for \code{var\_view\_}
and backward-evaluates \code{expr\_} with the now fully accumulated adjoint.

With \code{EqNode}, our code for Eq.~\ref{eq:eq-example}
may look like the following:
\begin{lstlisting}[style=customcpp]
    ad::Var<double, ad::scl> t;
    auto expr = (
        t = x * w,
        t + ad::sin(t)
    );
\end{lstlisting}
Note that we overloaded the assignment operator to create an \code{EqNode}.
We also overloaded the comma operator
and this will be discussed in more detail in Section~\ref{ssec:glue}.
Intuitively, during forward-evaluation, \code{x * w} will first be evaluated,
stored into \code{t}, and get reused when computing the subsequent expressions.
Backward-evaluation will still compute the correct gradient with respect to \code{x} and \code{w}.
This is also useful if users are interested in knowing sub-expression gradients.
Since \code{t} is a variable, its full gradient is also stored and can be retrieved.
