\subsection{Unary Node}\label{ssec:unary}

A unary operation on a scalar, vector, or a matrix is an element-wise 
operation applying a function $\phi$ element-wise.
More concretely, we say $f$ is a (element-wise) unary function if
\[
    f(x) = {[\phi(x_{ij})]}_{i=1,j=1}^{m,n}
\]
for some $\phi$.
The following is a simplified definition of a unary expression node:
\begin{lstlisting}[style=customcpp]
template <class Unary, class ExprType>
struct UnaryNode:
    ValueAdjView<typename util::expr_traits<ExprType>::value_t,
                 typename util::shape_traits<ExprType>::shape_t>,
    ExprBase<UnaryNode<Unary, ExprType>>
{
    UnaryNode(const expr_t& expr)
        : value_adj_view_t(nullptr, nullptr, 
                           expr.rows(), expr.cols())
        , expr_(expr)
    {}

    const var_t& feval() {
        auto&& a_expr = util::to_array(expr_.feval());
        util::to_array(this->get()) = Unary::fmap(a_expr);
        return this->get();
    }

    template <class T>
    void beval(const T& seed) {
        auto&& a_val = util::to_array(this->get());
        auto&& a_adj = util::to_array(this->get_adj());
        auto&& a_expr = util::to_array(expr_.get());
        a_adj = seed;
        expr_.beval(Unary::bmap(a_adj, a_expr, a_val));
    }

    ptr_pack_t bind_cache(ptr_pack_t begin) { 
        begin = expr_.bind_cache(begin);
        return value_adj_view_t::bind(begin);
    }

    util::SizePack bind_cache_size() const { 
        return single_bind_cache_size() + 
                expr_.bind_cache_size();
    }

    util::SizePack single_bind_cache_size() const {
        return {this->size(), this->size()};
    }

private:
    expr_t expr_;
};
\end{lstlisting}
\code{UnaryNode} is also a viewer of value and adjoint,
hence derives from \code{ValueAdjView}.
We follow the standard traits metaprogramming pattern by defining our own
traits classes \code{expr\_traits} and \code{shape\_traits} to unify the interface
for grabbing member aliases.
\code{UnaryNode} is also an expression node, and hence is tagged with \code{ExprBase}.
The first template parameter \code{Unary} is a class that defines
static member functions \code{fmap} and \code{bmap},
which define how to forward and backward-evaluate the current node, respectively.
The second template parameter indicates the operand's type,
and this is what makes our design ``expression-template based''.
The operand expression type can be quite complicated, but regardless of the type,
so long as it is a valid AD expression and 
the node only interacts with the AD expression interface, the current node is well-defined.
While not shown in the above code, we also make compile-time assertions
to check that \code{ExprType} is indeed a valid AD expression type.

The constructor first initializes the viewer with null pointers and the correct size.
Because a unary operation is always element-wise,
the value and adjoint size is always the same as the operand's size.
It then constructs the operand expression with the parameter \code{expr}.
While this may seem like there will be many copy constructions when constructing a full expression,
compilers are extremely well-equipped to optimize this with 
Return-Value-Optimization (RVO)~\cite{meyers:1995}.
This allows the compiler to eliminate temporary values and constructs the object 
one-time, inplace at the final variable location.
For example, the expression in Section~\ref{ssec:example}
\begin{lstlisting}[style=customcpp]
    auto expr = ad::sin(x1) + ad::cos(x2) * x3 - ad::log(x3);
\end{lstlisting}
will construct the full object one-time, inplace at \code{expr}.

The forward-evaluation defined by \code{feval} first
recurses on \code{expr\_} and then applies the unary operation
on the result by delegating to \code{Unary::fmap}.
We then save and return this result.
The code is extremely simple and compact and it applies for any shape (scalar, vector, or matrix).
Moreover, since we directly work with \code{Eigen} matrices of \code{double}, 
which view contiguous region of memory by design,
we are able to vectorize the forward-evaluation.

The backward-evaluation defined by \code{beval} first saves the seed to its adjoint.
See Section~\ref{ssec:binary} for why we save the seed.
We compute the seed for the operand by delegating to \code{Unary::bmap}.
Note that we pass in the current adjoint \code{a\_adj}, 
operand value \code{a\_expr}, and 
the forward-evaluated result \code{a\_val}.
We pass the seed because a child's seed may be more efficiently written 
than writing \code{seed * Unary::bmap(a\_expr, a\_val)}.
For example, if \code{Unary} represents \code{log},
the current approach will return \code{seed / a\_expr}, however
the less efficient approach will return \code{seed * (1./a\_expr)},
which requires an extra multiplication.
In fact, if the underlying expression is a vector or a matrix,
the extra multiplication is per element;
this seemingly innocuous difference creates a lot of extra computation.
This optimization refers back to Section~\ref{sssec:lazy-eval} regarding lazy evaluation.
As for providing the forward-evaluated result, 
some unary operations may be more optimized to reuse this value,
for example, exponential function.
In multi-dimensional cases, the next seeds will be \code{Eigen} expressions
of matrix object of \code{double}, hence, backward-evaluation is also vectorized.

The cache-related member functions can be explained altogether.
When binding to cache, it should first bind the underlying 
expression then bind itself to the next unbound location.
It is important to establish the same order in which we perform forward-evaluation.
This will make access to value and adjoint regions as linear as possible,
which is highly optimized for modern CPUs.
Moreover, this increases data locality, so (CPU) cache hits are increased.
Since this unary node itself requires cache,
the single cache size is its size for both value and adjoint,
and the total cache size is then its single cache size plus
the total cache size for the operand.

The following is an example of a Unary struct that will get passed in 
as the first template parameter to \code{UnaryNode}.
We show the definition for exponential:
\begin{lstlisting}[style=customcpp]
struct Exp
{
    template <class T>
	inline static auto fmap(const T& x) {
        using std::exp;
        using ad::exp;
        using Eigen::exp;
        return exp(x);
	}
    template <class S, class T, class U> 
	inline static auto bmap(const S& seed,
                            const T& x,
                            const U& f) {
        return seed * f;
	}
};
\end{lstlisting}
In \code{fmap}, we expose \code{exp} functions in various namespaces for argument-dependent lookup (ADL).
This allows the compiler to choose the \code{exp} function that best matches
the parameter type \code{x}.
\code{bmap} ignores the \code{x} value because the derivative of an exponential
is itself, which is the forward-evaluated value \code{f}.

The final piece is defining a function that will create a \code{UnaryNode}.
It is important to create such a function rather than explicitly
construct this \code{UnaryNode} object because function templates
are more flexible with deducing the types of its arguments, 
which is crucial when using expression templates
since the types can be arbitrarily complex.
The following is the \code{exp} definition:
\begin{lstlisting}[style=customcpp]
template <class Derived
        , class = std::enable_if_t<
            util::is_convertible_to_ad_v<Derived>>> 
inline auto exp(const Derived& node) 
{ 
    using expr_t = util::convert_to_ad_t<Derived>;
    expr_t expr = node;
    if constexpr (util::is_constant_v<expr_t>) { 
        return ad::constant(core::Exp::fmap(
                    util::to_array(expr.feval())) ); 
    } else { 
        return core::UnaryNode<core::Exp, expr_t>(expr); 
    } 
}
\end{lstlisting}
The second template parameter is a way to perform 
Substitution-Failure-Is-Not-An-Error (SFINAE) pattern~\cite{vandevoorde:2002}.
This function is only enabled when the operand expression \code{node}
``can be converted to an AD expression''.
Broadly, we defined this metaprogramming tool to check if 
\code{node} is a literal, an \code{Eigen} object, 
a \code{Var} object,
or already an AD expression (tagged with \code{ExprBase}).
A literal or an \code{Eigen} object is not an AD expression,
but once wrapped as a \code{ConstantNode} becomes an AD expression.
If it is a \code{Var} object, it can be converted to \code{VarView}, which is an AD expression.
This was the reason why we made \code{Var} inherit from \code{VarView} (see Section~\ref{ssec:var}).
If it already is an AD expression, no conversion is needed.
The \code{convert\_to\_ad\_t} will then convert the original type to the corresponding AD expression type,
and the converted object \code{expr} gets used 
to construct the \code{UnaryNode} with \code{Exp} as the first template parameter.
We make a further optimization to check at compile-time whether \code{expr}
is a constant AD expression, if so, this is eagerly evaluated.
This helps a lot during the actual AD evaluation because 
lazily evaluation of constants would unnecessarily evaluate them every time.
